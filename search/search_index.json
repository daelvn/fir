{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fir 2","text":"<p>Fir is a language-agnostic documentation generator framework. It is fully modular, which means you can mix a comment extractor with a different comment parser and emitter (but you aren't going to go through the hassle of writing anything). A set of generic modules for generating Markdown documentation is provided, don't expect much more (unless you press me to write more).</p> <p></p> <p>Tip</p> <p>Check out the new Fir 2 update! Renewed, with symbol support, verbatim inputs, and a little more. Changelog below.</p>"},{"location":"#Table-of-contents","title":"Table of contents","text":"<ul> <li>Fir 2</li> <li>Table of contents</li> <li>Install<ul> <li>Compiling from source</li> </ul> </li> <li>Changelog</li> <li>Documentation</li> <li>Extra features</li> <li>License</li> </ul>"},{"location":"#Install","title":"Install","text":"<p>You can install Fir via LuaRocks:</p> <pre><code>$ luarocks install fir\n</code></pre>"},{"location":"#Compiling-from-source","title":"Compiling from source","text":"<p>If you want to compile from source, you will need to install the following dependencies from LuaRocks: - <code>argparse</code> (CLI) - <code>ansikit</code> (CLI, optional if using CLI with <code>--silent</code>) - <code>lpath</code> (Library, CLI) - <code>lrexlib-pcre2</code> (Library, CLI) - <code>yuescript</code> (Compiling) - <code>alfons</code> (Compiling) - <code>rockbuild</code> (Compiling)</p> <p>Then, simply run <code>alfons compile make -v 1.0</code>. To clean the project, simply <code>alfons clean</code>.</p>"},{"location":"#Changelog","title":"Changelog","text":""},{"location":"#2x","title":"2.x","text":"<ul> <li>2.0.0 (04.10.2024)</li> </ul> <p>Fir 2 is being released! Out of the necessity to use a more modern documentation for my other, better project, Alfons, I decided to update this project. Here's the main changes:</p> <ul> <li>Revamped test suite generator. The <code>tests</code> format now actually works, and generates robust tests from your documentation that can check for many conditions. It's even TAP compliant for your CI needs!</li> <li>Symbol linking. Fir CLI using the Generic backend will now collect all symbols and let you link to them with <code>@@@</code> syntax.</li> <li>Verbatim inputs. Those inputs will be copied over directly to the output folder.</li> <li>Alfons integration. Fir automatically installs a loadable Alfons task, so you can integrate it into your Alfons workflows. Use <code>load 'fir'</code> to load it.</li> <li>Symbol summaries can now be longer than one line. The summary ends on the first line that does not begin with a \\ character. <li>Aliases are deranked. Now (under the Generic backend) aliases are not put beside the name.</li> <li>Better error reporting. No more unparsable errors.</li> <li>Output for MkDocs. The Generic Markdown emitter now has specific MkDocs options.</li> <li>Updated documentation. It's easier to understand how the fuck to use this.</li> <li>Documentation now uses Material for MkDocs. For a more clean, updated and powerful look and feel.</li> <li>Switched to more robust libraries. lpath for FS operations, lrexlib on PCRE2 backend for symbol syntax.</li> <li>Updated from MoonPlus to Yuescript. MoonPlus has not been a thing for years and instead transitioned into being Yuescript.</li>"},{"location":"#Documentation","title":"Documentation","text":"<p>Check out the documentation here.</p>"},{"location":"#Extra-features","title":"Extra features","text":"<p>I kindly welcome new features that anyone wants to suggest or add! Feel free to open an issue or PR.</p>"},{"location":"#License","title":"License","text":"<p>This project is Unlicensed, and released to the public domain. Do whatever you wish with it!</p>"},{"location":"generic/","title":"Generic module","text":"<p>The generic module comes with Fir by default to provide a standard backend for parsing and emitting. By default, it can emit Markdown documentation, as well as luassert tests.</p> <p>If you're looking for the tutorial to document your code using the default backend, it can be found here.</p>"},{"location":"generic/#The-generic-pipeline","title":"The generic pipeline","text":"<ul> <li>The comments are extracted through <code>fir.generic.backend</code>. Documentation here.</li> <li>Then, they are parsed by <code>fir.generic.parser</code>. Documentation here.</li> <li>Lastly, they are passed through a language emitter (<code>fir.generic.emit.*</code>). Documentation here.</li> </ul> <p>All the moving parts and data types are documented in their respective places.</p>"},{"location":"generic/#Integrating","title":"Integrating","text":"<p>By creating functions that work with the data types specified in the other parts of the documentation, you're able to replace parts of the generic pipeline with your own parts. This is:want useful, for example, if you want to change the way the comments get parsed.</p> <p>About the CLI</p> <p>The CLI was made to work only with the generic backend. You may have to roll your own CLI or adapt the existing one to use your own backend.</p>"},{"location":"generic/backend/","title":"fir.generic.backend","text":"<p>A generic implementation of a backend for the Fir documentation generator.</p> <p>This specific implementation uses a <code>language</code> module (defaults to <code>fir.generic.languages</code>) to parse comments from any file.</p> <p>Check out an example output of this backend here.</p>"},{"location":"generic/backend/#API","title":"API","text":"<p>This is the API provided to work with the generic backend.</p> Element Summary Functions extract Extracts comment from a string separated by newlines. Types GenericComment Comment returned by <code>extract</code>. Language Language type accepted by <code>extract</code>. <p>Extracts comment from a string separated by newlines.</p> <ul> <li><code>patterns:boolean</code> (<code>false</code>): Whether to use patterns for the language fields and ignore string or not.</li> <li><code>ignore:string</code> (<code>\"///\"</code>): String used to determine when to start or stop ignoring comments.</li> <li><code>merge:boolean</code> (<code>true</code>): Whether to merge adjacent single-line comments.</li> <li><code>paragraphs:boolean</code> (<code>true</code>): Whether to split multi-line comments by empty strings (<code>\"\"</code>).</li> </ul> <p>Comment returned by <code>extract</code>.</p> Format <pre><code>GenericComment {\n  start   :: number\n  end     :: number\n  content :: [string]\n}\n</code></pre> <p>Language type accepted by <code>extract</code>.</p> Format <pre><code>Language {\n  single     :: string\n  multi      :: [string]\n  extensions :: [string]\n}\n</code></pre>"},{"location":"generic/backend/#extract","title":"extract","text":"<p>:: input:string, language?:Language, options?:table -&gt; comments:[GenericComment]</p>"},{"location":"generic/backend/#GenericComment","title":"GenericComment","text":""},{"location":"generic/backend/#Language","title":"Language","text":""},{"location":"generic/parser/","title":"fir.generic.parser","text":"<p>A parser that works with the format provided by the generic backend.</p> <p>You can see an example of parser output here.</p>"},{"location":"generic/parser/#Helpers","title":"Helpers","text":"<p>Several functions that aid in the process of parsing.</p> Element Summary Functions determineSummaryBoundary Gets the boundary line where a summary ends and the description begins parseDescription Parses codeblocks, tags, headers and normal text in descriptions. Types DescriptionLine A single element in a description returned by <code>parseDescription</code> <p>Gets the boundary line where a summary ends and the description begins</p> <ul> <li>Gets the boundary line where a summary ends and the description begins</li> </ul> <p>Parses codeblocks, tags, headers and normal text in descriptions.</p>"},{"location":"generic/parser/#determineSummaryBoundary","title":"determineSummaryBoundary","text":"<p>:: content:GenericComment.content, lead:string -&gt; boundary:number</p>"},{"location":"generic/parser/#parseDescription","title":"parseDescription","text":"<p>:: description:[string] -&gt; description:[DescriptionLine], tags:[string]</p>"},{"location":"generic/parser/#Notes","title":"Notes","text":"<ul> <li>In a codeblock, the first character of every line is removed (for a space).</li> </ul>"},{"location":"generic/parser/#Supported-tags","title":"Supported tags","text":"<ul> <li><code>@internal</code> - Adds an <code>internal</code> true flag to the element.</li> </ul> <p>A single element in a description returned by <code>parseDescription</code></p> Format <pre><code>DescriptionLine {\n  type      :: string (text|snippet|header)\n  content   :: [string]\n  language? :: string -- only when type is snippet\n  title?    :: string -- only when type is snippet\n  n?        :: number -- only when type is header\n}\n</code></pre>"},{"location":"generic/parser/#DescriptionLine","title":"DescriptionLine","text":""},{"location":"generic/parser/#API","title":"API","text":"<p>This is the API provided to work with the generic parser.</p> Element Summary Functions parse Parses a list of GenericComments into a GenericAST Types GenericAST The AST produced by <code>parse</code>. <p>Parses a list of GenericComments into a GenericAST</p> <ul> <li>Parses a list of GenericComments into a GenericAST</li> </ul> <p>Aliases: <code>GenericSection, GenericSectionContent, GenericElement</code></p> <p>The AST produced by <code>parse</code>.</p> Format <pre><code>GenericAST {\n  title       :: string\n  description :: [DescriptionLine]\n  [n]         :: GenericSection { -- where n is the ID of the section\n    section :: GenericSectionDetails {\n      id          :: number\n      name        :: string\n      description :: [DescriptionLine]\n    }\n    content :: GenericSectionContent {\n      [name] :: GenericElement {\n        is          :: string (type|function|constant|class)\n        description :: [DescriptionLine]\n        name        :: [string] -- an array, meant to also contain aliases\n        summary     :: string\n        type        :: string -- only when `is` is `\"function\"` or `\"constant\"`\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"generic/parser/#parse","title":"parse","text":"<p>:: comments:[GenericComment], language:Language -&gt; ast:GenericAST</p>"},{"location":"generic/parser/#GenericAST","title":"GenericAST","text":""},{"location":"generic/emit/markdown/","title":"fir.generic.emit.markdown","text":"<p>An emitter that works with a <code>GenericAST</code> and turns it into markdown.</p>"},{"location":"generic/emit/markdown/#API","title":"API","text":"<p>This is the API provided to work with the generic markdown emitter.</p> Element Summary Functions emit Emits Markdown from a <code>GenericAST</code> emitDescription Emits Markdown from the description of an element. emitSection Emits Markdown from a <code>GenericSection</code> listAllSymbols Locates all symbols in an AST replaceSymbols Returns a string with the symbol syntax replaced with its documentation location <p>Emits Markdown from a <code>GenericAST</code></p> <ul> <li><code>tabs:table</code>: Adds tabbed syntax to the final output.<ul> <li><code>use:boolean|\"docsify\"|\"pymdownx\"</code> (<code>false</code>): Outputs tab syntax, either  docsify-tabs or pymdownx.tabbed.</li> <li><code>docsify_header:string</code> (<code>\"####\"</code>): Unused. Headers to use for docsify-tabs.</li> </ul> </li> <li><code>all:boolean</code> (<code>false</code>): Also emits hidden elements.</li> <li><code>sections:table</code>: Settings for sections.</li> <li><code>columns:table</code>: Settings for columns.<ul> <li><code>[n]:table</code>: (where <code>n</code> can be any number or <code>\"*\"</code>). Specifies the column names for section <code>n</code> (with fallback).<ul> <li><code>[1]:string</code> (<code>\"Element\"</code>) - Left column</li> <li><code>[2]:string</code> (<code>\"Summary\"</code>) - Right column</li> </ul> </li> </ul> </li> <li><code>types:table</code>: Aliases for types.<ul> <li><code>[type]:string</code>: (where <code>type</code> can be any of the types supported by GenericAST). Default values include <code>type=Types</code> and <code>function=Functions</code> among others.</li> </ul> </li> <li><code>symbols:{string:string}</code>: Map of symbols to their documentation locations</li> <li><code>symbols_in_code:boolean|'mkdocs'</code> (false): Whether to link symbols inside code. Only supports MkDocs.</li> </ul> <p>Emits Markdown from the description of an element.</p> <ul> <li><code>tabs:table</code>: Adds tabbed syntax to the final output.<ul> <li><code>use:boolean|\"docsify\"|\"pymdownx\"</code> (<code>false</code>): Outputs tab syntax, either  docsify-tabs or pymdownx.tabbed.</li> <li><code>docsify_header:string</code> (<code>\"####\"</code>): Headers to use for docsify-tabs.</li> </ul> </li> <li><code>symbols:{string:string}</code>: Map of symbols to their documentation location</li> <li><code>symbols_in_code:boolean|'mkdocs'</code> (false): Whether to link symbols inside code. Only supports MkDocs.</li> </ul>"},{"location":"generic/emit/markdown/#emit","title":"emit","text":"<p>:: ast:GenericAST, options:table -&gt; markdown:string</p>"},{"location":"generic/emit/markdown/#emitDescription","title":"emitDescription","text":"<p>:: desc:[DescriptionLine], options:table -&gt; markdown:string</p>"},{"location":"generic/emit/markdown/#Recognized-options","title":"Recognized options","text":"<ul> <li><code>headerOffset:number</code> (<code>1</code>): Offsets the header levels by n</li> </ul> <p>Emits Markdown from a <code>GenericSection</code></p> <p>Locates all symbols in an AST</p> <ul> <li><code>module:string</code>: Module string to use</li> <li><code>url_prefix:string</code>: Prefix of all documentation urls</li> </ul> <p>Returns a string with the symbol syntax replaced with its documentation location</p> <p><code>&lt;symbol&gt;</code></p>"},{"location":"generic/emit/markdown/#emitSection","title":"emitSection","text":"<p>:: section:GenericSection, options:table -&gt; markdown:string</p>"},{"location":"generic/emit/markdown/#listAllSymbols","title":"listAllSymbols","text":"<p>:: ast:GenericAST -&gt; {[symbol: string]: location:string}</p>"},{"location":"generic/emit/markdown/#replaceSymbols","title":"replaceSymbols","text":"<p>:: str:string, symbols:{string:string} -&gt; str:string</p>"},{"location":"generic/emit/tests/","title":"fir.generic.emit.tests","text":"<p>An emitter that works with a GenericAST and turns it into runnable tests.</p>"},{"location":"generic/emit/tests/#API","title":"API","text":"<p>This is the API provided to work with the test emitter.</p> Element Summary Functions emit Emits Lua tests from a <code>GenericAST</code> using <code>test</code> and <code>tagged-test</code> nodes. emitFunctionCall Emits a function call across languages emitIfStatement Emits an if statement across languages emitInlineFunctionDefinition Emits an inline function declaration across languages emitInternal Emits tests, as an internal function to be used in several parts. emitLocalDeclaration Emits a local declaration across languages emitPairsForStatement Emits a for statement across languages emitParentheses Emits an expression in parentheses across langauges emitString Emits a string across languages emitTableIndex Emits a table index across languages emitTableLiteral Emits a table literal across languages emitTestHeader Emits test headers. emitTestWrapper Wraps a test line in counters and error protectors <p>Emits Lua tests from a <code>GenericAST</code> using <code>test</code> and <code>tagged-test</code> nodes.</p> <ul> <li>Emits Lua tests from a <code>GenericAST</code> using <code>test</code> and <code>tagged-test</code> nodes.</li> </ul> <p>Aliases: <code>efn</code></p> <p>Emits a function call across languages</p> <p>Aliases: <code>eif</code></p> <p>Emits an if statement across languages</p> <ul> <li>Emits an if statement across languages</li> </ul> <p>Aliases: <code>eidef</code></p> <p>Emits an inline function declaration across languages</p> <p>Emits tests, as an internal function to be used in several parts.</p> <p>Aliases: <code>elocal</code></p> <p>Emits a local declaration across languages</p> <p>Aliases: <code>eforp</code></p> <p>Emits a for statement across languages</p> <ul> <li>Emits a for statement across languages</li> </ul> <p>Aliases: <code>eparen</code></p> <p>Emits an expression in parentheses across langauges</p> <p>Aliases: <code>estring</code></p> <p>Emits a string across languages</p> <p>Aliases: <code>eindex</code></p> <p>Emits a table index across languages</p> <ul> <li>Emits a table index across languages</li> </ul> <p>Aliases: <code>etable</code></p> <p>Emits a table literal across languages</p> <p>Emits test headers.</p> <p>Aliases: <code>ewrap</code></p> <p>Wraps a test line in counters and error protectors</p> <ul> <li>Wraps a test line in counters and error protectors</li> </ul>"},{"location":"generic/emit/tests/#emit","title":"emit","text":"<p>:: ast:GenericAST, options:table -&gt; code:string</p>"},{"location":"generic/emit/tests/#emitFunctionCall","title":"emitFunctionCall","text":"<p>:: fn:string, args:[string], options:table</p>"},{"location":"generic/emit/tests/#emitIfStatement","title":"emitIfStatement","text":"<p>:: condition:string, block:[string], options:table</p>"},{"location":"generic/emit/tests/#emitInlineFunctionDefinition","title":"emitInlineFunctionDefinition","text":"<p>:: args:[string], body:string, options:table</p>"},{"location":"generic/emit/tests/#emitInternal","title":"emitInternal","text":"<p>:: description:[DescriptionLine], options:table, append:function, prepend:function, placement:string -&gt; nil</p>"},{"location":"generic/emit/tests/#emitLocalDeclaration","title":"emitLocalDeclaration","text":"<p>:: name:string, lhs:string, options:table</p>"},{"location":"generic/emit/tests/#emitPairsForStatement","title":"emitPairsForStatement","text":"<p>:: k:string, v:string, iterator:string, body:string, options:string</p>"},{"location":"generic/emit/tests/#emitParentheses","title":"emitParentheses","text":"<p>:: content:string</p>"},{"location":"generic/emit/tests/#emitString","title":"emitString","text":"<p>:: content:string</p>"},{"location":"generic/emit/tests/#emitTableIndex","title":"emitTableIndex","text":"<p>:: table:string, index:string</p>"},{"location":"generic/emit/tests/#emitTableLiteral","title":"emitTableLiteral","text":"<p>:: tbl:table, options:table</p>"},{"location":"generic/emit/tests/#emitTestHeader","title":"emitTestHeader","text":"<p>:: node:table, count:number, options:table, append:function, prepend:function, placement:string -&gt; nil</p>"},{"location":"generic/emit/tests/#emitTestWrapper","title":"emitTestWrapper","text":"<p>:: name:string, count:number, body:string, options:table -&gt; code:string</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This page explains how to document your code to work with the generic/default parser.</p>"},{"location":"tutorial/#Top-header","title":"Top header","text":"<p>A first-level header (<code>#</code>) with an according description is inserted once with the following syntax (<code>&lt;single&gt;&lt;lead&gt;#...#&lt;lead&gt;&lt;single&gt;</code> ?):</p> PythonLua/MoonScript <pre><code>### Title ###\n# Description\n</code></pre> <pre><code>---# Title #---\n-- Description\n</code></pre> <p>The description can span as many lines as you wish as long as there is no empty line in the middle. If you want an empty line, just use an empty comment (this will also split the description into paragraphs).</p>"},{"location":"tutorial/#Hiding-the-document","title":"Hiding the document","text":"<p>You can stop the document from being generated if you place <code>@internal</code> in the description as the first word. This will stop the page from being generated unless <code>all</code> is set to <code>true</code> in the <code>emit</code> options.</p>"},{"location":"tutorial/#Section","title":"Section","text":"<p>You can add a section (<code>##</code>) with the following syntax (<code>&lt;single&gt;#...#&lt;single&gt;</code> ?):</p> PythonLua/MoonScript <pre><code>## Title ##\n# Description\n</code></pre> <pre><code>--# Title #--\n-- Description\n</code></pre> <p>The description can span as many lines as you wish as long as there is no empty line in the middle. If you want an empty line, just use an empty comment (this will also split the description into paragraphs).</p> <p>Every section generates with its own table of contents, separating between Types and Functions.</p>"},{"location":"tutorial/#Hiding-a-section","title":"Hiding a section","text":"<p>You can stop a section from being generated if you place <code>@internal</code> in the description as the first word. This will stop the section from being emitted unless <code>all</code> is set to <code>true</code> in the <code>emit</code> options.</p>"},{"location":"tutorial/#Functions","title":"Functions","text":"<p>You can document a function with the following syntax:</p> PythonLua/MoonScript <pre><code>## @function name alias1 alias2 :: type signature\n## Summary\n# Description\n</code></pre> <pre><code>--- @function name alias1 alias2 :: type signature\n--- Summary\n-- Description\n</code></pre> <p>The aliases must be separated by spaces and are not mandatory. The type signature is mandatory for a function and will be copied verbatim. The summary will be placed in its own paragraph and will be used for the table of contents as well.</p> <p>The description can span as many lines as you wish as long as there is no empty line in the middle. If you want an empty line, just use an empty comment (this will also split the description into paragraphs).</p>"},{"location":"tutorial/#Hiding-a-function","title":"Hiding a function","text":"<p>You can stop a function from being generated if you place <code>@internal</code> in the description as the first word. This will stop the function from being emitted unless <code>all</code> is set to <code>true</code> in the <code>emit</code> options.</p>"},{"location":"tutorial/#Types","title":"Types","text":"<p>You can document a type with the following syntax:</p> PythonLua/MoonScript <pre><code>## @type name alias1 alias2\n## Summary\n#:type Format\n# Describe your type here\n</code></pre> <pre><code>--- @type name alias1 alias2\n--- Summary\n--:type Format\n-- Describe your type here\n</code></pre> <p>It is customary to describe your type within a code block. Everything else is mostly the same as functions.</p>"},{"location":"tutorial/#Constants","title":"Constants","text":"<p>You can document a constant (does not need to be a constant, but...) using the following syntax:</p> <p>Note</p> <p>You can also use <code>@const</code> instead of <code>@constant</code>.</p> PythonLua/MoonScript <pre><code>## @constant name alias1 alias2 :: type\n## Summary\n# Description\n</code></pre> <pre><code>--- @constant name alias1 alias2 :: type\n--- Summary\n-- Description\n</code></pre> <p>The aliases must be separated by spaces and are not mandatory. The type is mandatory for a constant and will be copied verbatim. The summary will be placed in its own paragraph and will be used for the table of contents as well.</p> <p>The description can span as many lines as you wish as long as there is no empty line in the middle. If you want an empty line, just use an empty comment (this will also split the description into paragraphs).</p>"},{"location":"tutorial/#Classes","title":"Classes","text":"<p>You can document classes with the following syntax:</p> PythonLua/MoonScript <pre><code>## @class name alias1 alias2\n## Summary\n# Description\n</code></pre> <pre><code>--- @class name alias1 alias2\n--- Summary\n-- Description\n</code></pre> <p>The aliases must be separated by spaces and are not mandatory. The summary will be placed in its own paragraph and will be used for the table of contents as well.</p> <p>The description can span as many lines as you wish as long as there is no empty line in the middle. If you want an empty line, just use an empty comment (this will also split the description into paragraphs).</p>"},{"location":"tutorial/#Descriptions","title":"Descriptions","text":"<p>There are several tricks to make your descriptions look better.</p>"},{"location":"tutorial/#Headers","title":"Headers","text":"<p>You can place headers within descriptions as such. They will be automatically indented properly.</p> PythonLua/MoonScript <pre><code>## Header\n# Description follow-up\n</code></pre> <pre><code>--# Header\n-- Description follow-up\n</code></pre>"},{"location":"tutorial/#Code-blocks","title":"Code blocks","text":"<p>You can add a code block with the following syntax:</p> PythonLua/MoonScript <pre><code>#:language Title\n# code\n</code></pre> <pre><code>--:language Title\n-- code\n</code></pre> <p>If you need to continue a description after a codeblock, place a comment containing only <code>:</code> (no spaces) to stop the codeblock, or alternatively start a different codeblock.</p>"},{"location":"tutorial/#Ignoring-comments","title":"Ignoring comments","text":"<p>You can ignore a set of comments by placing <code>(single)///(single)</code> (like <code>#///#</code> or <code>--///--</code>) at both the start or the end of the region you want to ignore, like so:</p> PythonLua/MoonScript <pre><code>#///#\n# These comments will be ignored\n#///#\n</code></pre> <pre><code>--///--\n-- These comments will be ignored\n--///--\n</code></pre> <p>These comments will not be extracted at all. You can use this to document within your functions without the results actually being in the output (in fact, this is recommended).</p>"},{"location":"tutorial/#Linking-to-symbols","title":"Linking to symbols","text":"<p>You can use <code>@@@symbol@@@</code> outside of inline code or a code block to automatically link to a symbol in the project. Symbols are collected by taking all the names and aliases of all exported documentation.</p> <p>If there is a name conflict, you can prefix it with its parent module, like <code>@@@parent.symbol@@@</code>.</p>"},{"location":"tutorial/#Languages","title":"Languages","text":"<p>The language table passed to <code>extract</code> and <code>parse</code> define the comments that the Fir generic pipeline will look for.</p>"},{"location":"tutorial/#Lead","title":"Lead","text":"<p>The <code>&lt;lead&gt;</code> character mentioned here is the last character from the <code>single</code> comment field. So if your language looks like <code>{single = \"--\"}</code>, the lead will be <code>\"-\"</code>.</p>"},{"location":"tutorial/#Examples","title":"Examples","text":"<p>The Fir source code is documented using Fir! Read through the source code and compare to the documentation to see how it's documented.</p>"},{"location":"tutorial/CLI/","title":"CLI","text":"<p>This page describes the CLI to the Fir framework. It can only use the generic documentation format (but it can use different output formats).</p>"},{"location":"tutorial/CLI/#Installing","title":"Installing","text":"<p>The Fir CLI comes with the Fir framework via LuaRocks automatically.</p>"},{"location":"tutorial/CLI/#Configuration","title":"Configuration","text":"<p>The most important part to maintaining the documentation of a project with Fir is the configuration. The configuration takes form as a Lua or MoonScript file and it defines the inputs, outputs, formats and other things related to documentation.</p> <p>The file must be named <code>Fir.lua</code> or <code>Fir.moon</code> for it to be detected automatically, but you can also use <code>-c</code> or <code>--config</code> to change the configuration file, and <code>--config-language</code> to set the language it should be loaded as (only supports <code>lua</code> and <code>moon</code>).</p> <p>About MoonScript</p> <p>Note: To use a Fir.moon configuration file, or any configuration file written in MoonScript, you need to install MoonScript via LuaRocks with the following command: <code>luarocks install moonscript</code></p> <p>Here follows a complete description of all the options that the Fir CLI accepts.</p> LuaMoonScript <pre><code>--- General config\nname = \"Fir\"      -- name of your project, not mandatory\n--- Format\n-- turns into fir.generic.emit.&lt;format&gt;\nformat = \"markdown\" -- only markdown is included by default\n--- Emit options\nemit = {\n  tabs = {\n    use = false,            -- Whether to use Tab syntax in Markdown or not\n    docsify_header = \"####\" -- Header to use in the Docsify Tab syntax\n  },\n  all = false,  -- Also emit `@internal` sections\n  columns = {}, -- Modify the TOC\n  types = {     -- TOC section titles\n    type = \"Types\",\n    function = \"Functions\",\n    constant = \"Constants\",\n    class = \"Classes\",\n    test = \"Tests\",\n    table = \"Tables\",\n    field = \"Fields\",\n    variable = \"Variables\"\n  }\n}\n--- Backend options\nbackend = {\n  patterns = false,   -- Whether to use patterns for the language strings\n  ignore = \"///\",     -- String used to determine when to start or stop ignoring comments\n  merge = true,       -- Whether to merge adjacent single-line comments\n  paragraphs = true,  -- Whether to split multi-line comments by empty strings\n}\n--- Language\n-- defines the way comments should be extracted\n-- with support for single-line and multiline comments.\nlanguage = {\n  single = \"--\",\n  multi  = {\n    \"--[[\",\n    \"]]--\"\n  }\n}\n--- Files\n-- Input\n-- Every entry is passed through lpath.fs.glob, so you can use\n-- wildcards. Reference below.\ninput = {\n  \"fir/**.yue\",\n  -- Verbatim files will be placed in the output folder as they\n  -- are.\n  { \"fir/**.md\", verbatim: true }\n}\n-- Transform\n-- Function that changes the filepath to be written.\n-- If the input is fir/generic/emit/markdown.yue, this function\n-- will transform it into `generic/emit/markdown.md`, for example.\ntransform = function (path)\n  if (path:match \"yue$\") then\n    return (path:match \"fir/(.+)%.yue\") .. \".md\"\n  else\n    return (path:match \"fir/(.+)\")\n  end\nend\n-- Output folder\noutput = \"docs\"\n-- Ignore\n-- List of files to ignore. Also supports wildcards (reference below).\nignore = {\n  \"fir/version.mp\",\n  \"fir/file.mp\"\n}\n</code></pre> <pre><code>config:\n  --- General config\n  name: \"Fir\"      -- name of your project, not mandatory\n  --- Format\n  -- turns into fir.generic.emit.&lt;format&gt;\n  format: \"markdown\" -- only markdown is included by default\n  --- Emit options\n  emit: {\n    tabs: {\n      use:  false,            -- Whether to use Tab syntax in Markdown or not\n      docsify_header:  \"####\" -- Header to use in the Docsify Tab syntax\n    },\n    all:  false,  -- Also emit `@internal` sections\n    columns:  {}, -- Modify the TOC\n    types:  {     -- TOC section titles\n      type:  \"Types\",\n      function:  \"Functions\",\n      constant:  \"Constants\",\n      class:  \"Classes\",\n      test:  \"Tests\",\n      table:  \"Tables\",\n      field:  \"Fields\",\n      variable:  \"Variables\"\n    }\n  }\n  --- Backend options\n  backend:  {\n    patterns:  false,   -- Whether to use patterns for the language strings\n    ignore:  \"///\",     -- String used to determine when to start or stop ignoring comments\n    merge:  true,       -- Whether to merge adjacent single-line comments\n    paragraphs:  true,  -- Whether to split multi-line comments by empty strings\n  }\n  --- Language\n  -- defines the way comments should be extracted\n  -- with support for single-line and multiline comments.\n  language:\n    single: \"--\"\n    multi: {\n      \"--[[\"\n      \"]]--\"\n    }\n  }\n  -- Verbatim files will be placed in the output folder as they\n  -- are.\n  --- Files\n  -- Input\n  -- Every entry is passed through lpath.fs.glob (reference below),\n  -- so you can use wildcards.\n  input: {\n    \"fir/**.yue\"\n    -- Verbatim files will be placed in the output folder as they\n    -- are.\n    { \"fir/**.md\", verbatim: true }\n  }\n  -- Transform\n  -- Function that changes the filepath to be written.\n  -- If the input is fir/generic/emit/markdown.yue, this function\n  -- will transform it into `generic/emit/markdown.md`\n  transform: (path) -&gt;\n    if path\\match \"yue$\"\n      (path\\match \"fir/(.+)%.mp\") .. \".md\"\n    else\n      path\\match \"fir/(.+)\"\n  -- Output folder\n  output: \"docs\"\n  -- Ignore\n  -- List of files to ignore. Also supports wildcards (reference below).\n  ignore: {\n    \"fir/version.mp\"\n    \"fir/file.mp\"\n  }\n</code></pre>"},{"location":"tutorial/CLI/#Wildcards","title":"Wildcards","text":"<p>Wildcards work as described in the lpath <code>fs.glob</code> function documentation, with a modification that has been made by Fir.</p> <p><code>**</code> not followed by the path separator will be turned into <code>**/*</code>. This is because <code>fs.glob</code> does not work with <code>**.txt</code> directly, but needs to have <code>**/*.txt</code>.</p>"},{"location":"tutorial/CLI/#Generating","title":"Generating","text":"<p>Then you can simply generate your docs with <code>fir generate</code> (or <code>fir g</code> for shory). This will automatically create all folders and files necessary.</p>"},{"location":"tutorial/CLI/#Viewing","title":"Viewing","text":"<p>You may only want the Markdown files, but I recommend using a project like Docsify or Material for MkDocs to make your documentation look better as a webpage. The Markdown generic emitter has some facilities to integrate with both Docsify (like comments for the <code>docsify-tabs</code> plugin) and MkDocs.</p> <p>This page is currently using Material for MkDocs.</p>"},{"location":"tutorial/alfons/","title":"Using from Alfons","text":"<p>As of Fir 2, you can use Fir directly from Alfons without having to go through a shell interface or have a separate configuration file. The integration is installed automatically when you install the <code>fir</code> LuaRocks package.</p>"},{"location":"tutorial/alfons/#Loading","title":"Loading","text":"<p>It is recommended that you load external tasks in the <code>always</code> task. In rare cases (using the Alfons API) this might be disabled.</p> LuaMoonScript <pre><code>function always()\n  load \"fir\"\nend\n</code></pre> <pre><code>tasks:\n  always: =&gt; load 'fir'\n</code></pre>"},{"location":"tutorial/alfons/#Using","title":"Using","text":"<p>You can use Fir from Alfons by calling <code>tasks.fir</code> once it is loaded (which should be always). The task takes the following arguments:</p> Argument Type Default Meaning <code>generate</code> Boolean None Equivalent to CLI <code>generate</code> command <code>dump</code> Boolean None Equivalent to CLI <code>dump</code> command <code>reader</code> <code>path:string -&gt; content:string</code> Alfons <code>readfile</code> Function that reads the content of a file <code>writer</code> <code>path:string, content:string -&gt; void</code> Alfons <code>writefile</code> Function that writes the content of a file <code>config</code> Table None A configuration as described for <code>Fir.moon</code>/<code>Fir.lua</code> <p>If you have a Firfile that looks like the following:</p> LuaMoonScript <pre><code>name = \"Fir\"\nformat = \"markdown\"\n</code></pre> <pre><code>config:\n  name: 'Fir'\n  format: 'markdown'\n</code></pre> <p>Then you would call Fir in Alfons as such:</p> LuaMoonScript <pre><code>function use_fir()\n  tasks.fir {\n    generate = true,\n    config = {\n      name = \"Fir\",\n      format = \"markdown\"\n    }\n  }\nend\n</code></pre> <pre><code>tasks:\n  use_fir: =&gt;\n    tasks.fir generate: true, config:\n      name: 'Fir'\n      format: 'markdown'\n</code></pre>"},{"location":"tutorial/alfons/#readerwriter","title":"<code>reader</code>/<code>writer</code>","text":"<p>It is possible to configure <code>reader</code> and <code>writer</code> so that you can apply transformations to the files being read or written. For example, if you are copying over your <code>README.md</code> to an <code>index.md</code> like Fir does, you might want to change the syntax of some components like admonitions. This is how you could do that:</p> LuaMoonScript <pre><code>function generate_docs()\n  tasks.fir {\n    generate = true,\n    writer = function(path, content)\n      if path == \"README.md\" then\n        writefile(path, content:gsub('&gt; [!TIP]\\n&gt; ', '!!! tip\\n    '))\n      else\n        writefile(path, content)\n      end\n    end,\n    config = {\n      name = \"Fir\",\n      format = \"markdown\"\n    }\n  }\nend\n</code></pre> <pre><code>tasks:\n  generate_docs: =&gt;\n    tasks.fir generate: true,\n      writer: (path, content) =&gt;\n        if path == 'README.md'\n          writefile path, content\\gsub '&gt; [!TIP]\\n&gt; ', '!!! tip\\n    '\n        else\n          writefile path, content\n      config:\n        name: 'Fir'\n        format: 'markdown'\n</code></pre>"},{"location":"tutorial/tests/","title":"Tests","text":"<p>This page explains how to use the <code>tests</code> Generic emitter to generate tests. The emitter generates a Lua file that is, re-parsable by Fir to generate Markdown information about the test. So, if desired, a test pipeline can be run twice, once to generate the tests, and another to generate the test documentation.</p> <p>A lot more functionality can be enabled if using the <code>luassert</code> module.</p>"},{"location":"tutorial/tests/#Configuring-test-emitting","title":"Configuring test emitting","text":"<p>Below is the configuration for test emitting. Format must be set to <code>\"emit\"</code> for these options to apply.</p> Option Type Default Meaning <code>module</code> String GenericAST.title Name of the module to <code>require</code> <code>header</code> String None Code or comments to append to the comment header <code>subheader</code> String <code>'General'</code> Name of the documentation section for tests <code>trim</code> Boolean <code>true</code> Whether to trim spaces on test lines <code>newline</code> String <code>\\n</code> Newline character <code>luassert</code> Boolean <code>true</code> Whether to use <code>luassert</code> or not <code>print</code> <code>'pretty'</code>|<code>'plain'</code>|<code>'plain-verbose'</code>|<code>'tap'</code>|<code>false</code> <code>'pretty'</code> Whether to print test parts and results <code>testHeaders</code> Boolean <code>true</code> Whether to emit documentation headers for each test <code>docs</code> Boolean <code>true</code> Whether to add comments to the tests at all <code>auto_unpack</code> Boolean <code>false</code> Whether to unpack each symbol automatically <code>unpack</code> [String] None List of symbols to unpack, making them accessible directly without prefixing with <code>M</code> <code>snippet</code> String None Snippet of code to add before all the tests <code>all</code> Boolean None Whether to set all tags to <code>true</code> (Execute all tests)"},{"location":"tutorial/tests/#Printing-modes","title":"Printing modes","text":"<p>Fir now offers different printing modes depending on your needs.</p> <ul> <li><code>pretty</code> will print pending and failed tests, as well as results, using colors.</li> <li><code>plain</code> does exactly the same with no color.</li> <li>The <code>-verbose</code> variants will also print successes.</li> <li><code>tap</code> tries to output according to the TAP protocol</li> <li>Setting it to <code>false</code> will not print anything</li> </ul>"},{"location":"tutorial/tests/#Structure-of-a-test","title":"Structure of a test","text":"<ul> <li>Header</li> <li><code>option.header</code></li> <li>Imports (<code>luassert</code> and your module)</li> <li>Unpack <code>options.unpack</code></li> <li><code>options.snippet</code></li> <li>Parse arguments (<code>{...}</code>) into a tag list (<code>tags</code>)</li> <li><code>options.all</code> setup</li> <li>Insert docs description and <code>options.subheader</code> as its header</li> <li>Iterate sections<ul> <li>Emit each test</li> </ul> </li> </ul>"},{"location":"tutorial/tests/#How-unpacking-works","title":"How unpacking works","text":"<p>There are two kinds of unpacking: through <code>options.unpack</code> or by setting <code>options.auto_unpack</code>.</p>"},{"location":"tutorial/tests/#Explicit-unpacking","title":"Explicit unpacking","text":"<p>All the symbols listed in <code>options.unpack</code> will be unpacked in the form <code>(local) &lt;symbol&gt; = M['&lt;symbol&gt;']</code> where <code>M</code> is your required module.</p>"},{"location":"tutorial/tests/#Automatic-unpacking","title":"Automatic unpacking","text":"<p>The metatable of the environment is set so that <code>M</code> is a fallback table. This way, all functions and symbols can be accessed automatically without the need to list them in an unpack.</p>"},{"location":"tutorial/tests/#Test-lines","title":"Test lines","text":""},{"location":"tutorial/tests/#Test-configuration","title":"Test configuration","text":"<p>These configuration comments should go before the test you want to mark.</p> <p>Mark a test as pending: <code>?$ pending</code> </p>"},{"location":"tutorial/tests/#Verbatim-tests","title":"Verbatim tests","text":"<p>These kinds of tests are pasted into the code verbatim.</p> Lua <pre><code>-- ?! print(VALUE)\n</code></pre>"},{"location":"tutorial/tests/#Verbatim-setup","title":"Verbatim setup","text":"<p>These comments will embed code lines directly into the output, as to setup tests.</p> Lua <pre><code>-- !! array = {1, 2, 3}\n</code></pre>"},{"location":"tutorial/tests/#Truthy-tests","title":"Truthy tests","text":"<p>These kinds of tests check for a truthy result. The contents are placed inside <code>assert</code>, or <code>assert.truthy</code> in the case of using <code>luassert</code>.</p> Lua <pre><code>-- ?? VALUE\n</code></pre>"},{"location":"tutorial/tests/#Tagged-tests","title":"Tagged tests","text":"<p>Tagged tests are tests that are only run if a certain tag is passed to the runner file. Otherwise equivalent to Truthy tests</p> Lua <pre><code>-- ?? tag: VALUE\n</code></pre>"},{"location":"tutorial/tests/#luassert-tests","title":"<code>luassert</code> tests","text":"<p>These tests directly leverage <code>luassert</code> to check for different conditions. The error message <code>err</code> is always optional.</p> Letter <code>luassert</code> Meaning <code>T</code> <code>is_true(value, err)</code> Check for <code>true</code> <code>t</code> <code>truthy(value, err)</code> Check for a truthy value <code>F</code> <code>is_false(value, err)</code> Check for <code>false</code> <code>f</code> <code>falsy(value, err)</code> Check for a falsy value <code>E</code> <code>has_no.errors(fn, err)</code> Check that a function has no errors <code>e</code> <code>errors(fn, expected_err, err)</code> Checks that a function errors <code>n</code> <code>near(num, expected_num, tolerance)</code> Checks that a number is within tolerance of expectation <code>u</code> <code>unique(list, err, deep?)</code> Checks that every value in a list is unique <code>:</code> <code>matches(value, pattern, err)</code> Checks that a value matches a Lua pattern <code>=</code> <code>equals(value, expected, err)</code> Checks that two values are equal (<code>==</code>) <code>~</code> <code>same(value, expected, err)</code> Checks that two values are similar through a deep compare <code>#</code> type Using the tag, checks if the passed expression is (type) <p>You can negate the test result by putting a caret (<code>^</code>) between the two interrogation signs.</p> Lua <pre><code>-- ??t truthy_value, \"Not truthy\"\n-- ?^?= value, expected, \"They are, but shouldn't be equal\"\n-- ??# string: stringy_value, \"Not a string\"\n</code></pre>"},{"location":"tutorial/tests/#luassert-tagged-tests","title":"<code>luassert</code> tagged tests","text":"<p>Equivalent to <code>luassert</code> tests, but with tags as in Tagged test syntax.</p> <p>Warning</p> <p>The type <code>luassert</code> test (<code>??#</code>) does not work with tagged tests because they use the tag as the type to test for.</p>"}]}